(function() {
  var app, appServer, assert, describe, express, fs, path, phantom, t, temp, vows;

  vows = require('vows');

  assert = require('assert');

  phantom = require('../phantom');

  express = require('express');

  temp = require('temp');

  path = require('path');

  fs = require('fs');

  describe = function(name, bat) {
    return vows.describe(name).addBatch(bat)["export"](module);
  };

  t = function(fn) {
    return function() {
      fn.apply(this, arguments);
    };
  };

  app = express();

  app.get('/', function(req, res) {
    return res.send("<html>\n  <head>\n    <title>Test page title</title>\n    <script src=\"https://ajax.googleapis.com/ajax/libs/jquery/1.6.4/jquery.min.js\"></script>\n  </head>\n  <body>\n    <div id=\"somediv\">\n      <div class=\"anotherdiv\">Some page content</div>\n    </div>\n    <button class=\"clickme\" style=\"position: absolute; top: 123px; left: 123px; width: 20px; height; 20px\" onclick=\"window.i_got_clicked = true;\" />\n  </body>\n</html>");
  });

  appServer = app.listen();

  describe("Pages", {
    "A Phantom page": {
      topic: t(function() {
        return phantom.create({
          port: 12303
        }, (function(_this) {
          return function(ph) {
            return ph.createPage(function(page) {
              return _this.callback(null, page, ph);
            });
          };
        })(this));
      }),
      "can open a URL on localhost": {
        topic: t(function(page) {
          return page.open("http://127.0.0.1:" + (appServer.address().port) + "/", (function(_this) {
            return function(status) {
              return _this.callback(null, page, status);
            };
          })(this));
        }),
        "and succeed": function(err, page, status) {
          return assert.equal(status, "success");
        },
        "and the page, once it loads,": {
          topic: t(function(page, status) {
            return setTimeout((function(_this) {
              return function() {
                return _this.callback(null, page);
              };
            })(this), 1500);
          }),
          "has a title": {
            topic: t(function(page) {
              return page.evaluate((function() {
                return document.title;
              }), (function(_this) {
                return function(title) {
                  return _this.callback(null, title);
                };
              })(this));
            }),
            "which is correct": function(title) {
              return assert.equal(title, "Test page title");
            }
          },
          "has cookies": {
            topic: t(function(page) {
              return page.getCookies((function(_this) {
                return function(cookies) {
                  return _this.callback(null, cookies);
                };
              })(this));
            }),
            "which works correctly": function(cookies) {
              return assert.ok(cookies, "cookies should not be empty");
            }
          },
          "can inject Javascript from a file": {
            topic: t(function(page) {
              return page.injectJs('test/inject.js', (function(_this) {
                return function(success) {
                  return _this.callback(null, success);
                };
              })(this));
            }),
            "and succeed": function(success) {
              return assert.ok(success, "Injection should return true");
            }
          },
          "can evaluate DOM nodes": {
            topic: t(function(page) {
              return page.evaluate((function() {
                return document.getElementById('somediv');
              }), (function(_this) {
                return function(node) {
                  return _this.callback(null, node);
                };
              })(this));
            }),
            "which match": function(node) {
              assert.equal(node.tagName, 'DIV');
              return assert.equal(node.id, 'somediv');
            }
          },
          "can evaluate scripts defined in the header": {
            topic: t(function(page) {
              return page.evaluate((function() {
                return $('#somediv').html();
              }), (function(_this) {
                return function(html) {
                  return _this.callback(null, html);
                };
              })(this));
            }),
            "which return the correct result": function(html) {
              html = html.replace(/\s\s+/g, "");
              return assert.equal(html, '<div class="anotherdiv">Some page content</div>');
            }
          },
          "can set a nested property": {
            topic: t(function(page) {
              return page.set('settings.loadPlugins', true, (function(_this) {
                return function(oldVal) {
                  return _this.callback(null, page, oldVal);
                };
              })(this));
            }),
            "and get it again": {
              topic: t(function(page, oldVal) {
                return page.get('settings.loadPlugins', (function(_this) {
                  return function(val) {
                    return _this.callback(null, oldVal, val);
                  };
                })(this));
              }),
              "and they match": function(err, oldVal, val) {
                return assert.equal(oldVal, val);
              }
            }
          },
          "can simulate clicks on page locations": {
            topic: t(function(page) {
              page.sendEvent('click', 133, 133);
              return page.evaluate((function() {
                return window.i_got_clicked;
              }), (function(_this) {
                return function(clicked) {
                  return _this.callback(null, clicked);
                };
              })(this));
            }),
            "and have those clicks register": function(clicked) {
              return assert.ok(clicked);
            }
          },

          /*
          "can register an onAlert handler":
            topic: t (page) ->
              page.set 'onAlert', (msg) =>
                @callback null, msg
              page.evaluate (-> alert "Hello, world!")
          
            "which works correctly": (msg) ->
              assert.equal msg, "Hello, world!"
           */

          /*
          "can register an onConsoleMessage handler":
            topic: t (page) ->
              page.set 'onConsoleMessage', (msg) =>
                @callback null, msg
              page.evaluate (-> console.log "Hello, world!")
          
            "which works correctly": (msg) ->
              assert.equal msg, "Hello, world!"
           */
          "can register an onConsoleMessage handler": {
            topic: t(function(page) {
              page.onConsoleMessage((function(_this) {
                return function(msg) {
                  return _this.callback(null, msg);
                };
              })(this));
              return page.evaluate((function() {
                return console.log("Hello, world!");
              }));
            }),
            "which works correctly": function(msg) {
              return assert.equal(msg, "Hello, world!");
            }
          },
          "can render the page to a file": {
            topic: t(function(page) {
              var fileName;
              fileName = temp.path({
                suffix: '.png'
              });
              return page.render(fileName, (function(_this) {
                return function() {
                  return _this.callback(null, fileName);
                };
              })(this));
            }),
            "which is created": function(fileName) {
              return assert.ok(fs.existsSync(fileName), "rendered image should exist");
            },
            teardown: function(fileName) {
              return fs.unlink(fileName);
            }
          }
        }
      },
      teardown: function(page, ph) {
        appServer.close();
        return ph.exit();
      }
    }
  });

}).call(this);
