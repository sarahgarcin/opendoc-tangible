(function() {
  var array_flatten, fs, main, minify, optparse, render, stringify_unicode, uglify;

  fs = require('fs');

  uglify = require('uglify-js');

  optparse = require('optparse');

  array_flatten = function(arr, acc) {
    var v, _i, _len;
    if (typeof acc === 'undefined') {
      acc = [];
    }
    if (typeof arr === 'string') {
      acc.push(arr);
      return acc;
    }
    if (arr.constructor !== Array) {
      throw "Value is not an Array nor a String!";
    }
    for (_i = 0, _len = arr.length; _i < _len; _i++) {
      v = arr[_i];
      if (typeof v === 'string') {
        acc.push(v);
      } else if (v.constructor === Array) {
        array_flatten(v, acc);
      } else {
        throw "Value is not an Array nor a String!";
      }
    }
    return acc;
  };

  stringify_unicode = function(str) {
    str = str.replace(/[\u0100-\uffff]/g, function(ch) {
      return "\\u" + ('0000' + ch.charCodeAt(0).toString(16)).substr(-4);
    });
    str = str.replace(/[\x00-\x08\x0b-\x1f\x7f-\xff]/g, function(ch) {
      return "\\x" + ('00' + ch.charCodeAt(0).toString(16)).substr(-2);
    });
    return str;
  };

  minify = function(data, minify_options) {
    var ast;
    ast = uglify.parser.parse(data);
    ast = uglify.uglify.ast_mangle(ast, minify_options);
    ast = uglify.uglify.ast_squeeze(ast);
    return uglify.uglify.gen_code(ast, minify_options);
  };

  render = function(filename, depth, options) {
    var content, data, e, elements, encoding, i, p, tags, _i, _ref;
    tags = {
      include: function(args) {
        if (args.length > 1 && args[1].indexOf('c') !== -1 && options.minify === false) {
          options.comment = true;
        }
        return render(args[0], depth + '    ', options);
      },
      version: function() {
        return options.version;
      },
      include_and_minify: function(args) {
        var d;
        if (args.length > 1 && args[1].indexOf('c') !== -1 && options.minify === false) {
          options.comment = true;
        }
        d = render(args[0], depth + '    ', options);
        if (options.minify) {
          return minify(array_flatten(d).join(''), options);
        }
        return d;
      }
    };
    console.warn(depth + " [.] Rendering", filename);
    data = fs.readFileSync(filename, encoding = 'utf8').replace(/\s+$/, '');
    content = [];
    if (options.comment) {
      content.push('\n// ' + depth + '[*] Including ' + filename + '\n');
    }
    elements = data.split(/<!--\s*([^>]+)\s*-->/g);
    for (i = _i = 0, _ref = elements.length; 0 <= _ref ? _i < _ref : _i > _ref; i = 0 <= _ref ? ++_i : --_i) {
      e = elements[i];
      if (i % 2 === 0) {
        content.push(e);
      } else {
        p = e.split(' ');
        content.push(tags[p[0]](p.slice(1)));
      }
    }
    if (options.comment) {
      content.push('\n// ' + depth + '[*] End of ' + filename + '\n');
    }
    return content;
  };

  main = function() {
    var content, filename, filenames, options, parser, switches;
    switches = [['-p', '--pretty', 'Prettify javascript'], ['-m', '--minify', 'Minify javascript'], ['-s', '--set-version [VERSION]', 'Set the value of version tag']];
    options = {
      minify: false,
      toplevel: true,
      version: 'unknown'
    };
    parser = new optparse.OptionParser(switches);
    parser.on('pretty', function() {
      return options.beautify = true;
    });
    parser.on('minify', function() {
      return options.minify = true;
    });
    parser.on('set-version', function(_, version) {
      return options.version = version;
    });
    filenames = parser.parse((process.ARGV || process.argv).slice(2));
    content = (function() {
      var _i, _len, _results;
      _results = [];
      for (_i = 0, _len = filenames.length; _i < _len; _i++) {
        filename = filenames[_i];
        _results.push(render(filename, '', options));
      }
      return _results;
    })();
    content.push('\n');
    return process.stdout.write(stringify_unicode(array_flatten(content).join('')), 'utf8');
  };

  main();

}).call(this);
